#need the "faster_rcnn_inception_resnet_v2_atrous_coco_11_06_2017.tar.gz" downloaded 
#from the modelzoo and decompressed first

import time

import numpy as np
import os
import six
import six.moves.urllib as urllib
import sys
import tarfile
import tensorflow as tf
import zipfile

from collections import defaultdict
from io import StringIO
from PIL import Image
from utils import label_map_util
from utils import visualization_utils as vis_util
import collections
import json

#helper code
def load_image_into_numpy_array(image):
        (im_width, im_height) = image.size
        return np.array(image.getdata()).reshape((im_height, im_width, 3)).astype(np.uint8)

#output bounding boxes as json
def json_output(w, h, ymin, xmin, ymax, xmax, label_str, frame=0, video_id=0):
        # pyautogui.hotkey('command', 'up')
        (im_width, im_height) = (w, h)
        (left, right, top, bottom) = (xmin * im_width, xmax * im_width, ymin * im_height, ymax * im_height)
        #return as x, y, w, h
        w = right-left
        h = bottom - top
        return json.dumps({"x": left, "y": top, "w": w, "h": h, "type": label_str, "frame": frame, "video_id": video_id})

def output_boxes_array(w, h, ts, boxes, classes, scores, category_index, instance_masks=None, keypoints=None, max_boxes_to_draw=20, min_score_thresh=.5, agnostic_mode=False):
        print("drw array")
        box_to_display_str_map = collections.defaultdict(list)
        print("box_to_display_str_map")
        box_to_color_map = collections.defaultdict(str)
        box_to_class_map = collections.defaultdict(str)
        print("box_to_color_map")
        box_to_instance_masks_map = {}
        print("box_to_instance_masks_map")
        box_to_keypoints_map = collections.defaultdict(list)
        print("box_to_keypoints_map")
        if not max_boxes_to_draw:
                max_boxes_to_draw = boxes.shape[0]
                print("max_boxes_to_draw")
        for i in range(min(max_boxes_to_draw, boxes.shape[0])):
                if scores is None or scores[i] > min_score_thresh:
                        box = tuple(boxes[i].tolist())
                        print("box1")
                        if instance_masks is not None:
                                box_to_instance_masks_map[box] = instance_masks[i]
                                print("box_to_instance_masks_map[box]")
                        if keypoints is not None:
                                box_to_keypoints_map[box].extend(keypoints[i])
                                print("box_to_keypoints_map[box]")
                        if scores is None:
                                box_to_color_map[box] = 'black'
                                print("box_to_color_map[box]")
                        else:
                                if not agnostic_mode:
                                        if classes[i] in category_index.keys():
                                                class_name = category_index[classes[i]]['name']
                                        else:
                                                class_name = 'N/A'
                                        display_str = '{}: {}%'.format( class_name, int(100*scores[i]))
                                else:
                                        display_str = 'score: {}%'.format(int(100 * scores[i]))
                                box_to_display_str_map[box].append(display_str)
                                box_to_class_map[box] = class_name
                                if agnostic_mode:
                                        box_to_color_map[box] = 'DarkOrange'
                                else:
                                        box_to_color_map[box] = 'DarkOrange'

        # for box, color in six.iteritems(box_to_color_map):
        jsonbox_list = []
        for box, display in six.iteritems(box_to_class_map):
                # if 'car' in str(display):
                ymin, xmin, ymax, xmax = box
                        # print(ymin, xmin, ymax, xmax)
                        # draw_bounding_box(ymin, xmin, ymax, xmax)
                        # print(display)
                jsonbox = json_output(w, h, ymin, xmin, ymax, xmax, display, ts)
                jsonbox_list.append(jsonbox)
        print(jsonbox_list)
        return jsonbox_list

def load_models(path):
        MODEL_NAME = path+'faster_rcnn_inception_resnet_v2_atrous_coco_11_06_2017'
        # MODEL_NAME = 'ssd_mobilenet_v1_coco_11_06_2017'
        # MODEL_NAME = 'ssd_inception_v2_coco_11_06_2017'
        # MODEL_NAME = 'faster_rcnn_resnet101_coco_11_06_2017'
        # MODEL_NAME = 'rfcn_resnet101_coco_11_06_2017'
        # Path to frozen detection graph. This is the actual model that is used for the object detection.
        PATH_TO_CKPT = MODEL_NAME + '/frozen_inference_graph.pb'
        # List of the strings that is used to add correct label for each box.
        PATH_TO_LABELS = os.path.join(path+'data', 'mscoco_label_map.pbtxt')

        NUM_CLASSES = 90
        #load the model
        global detection_graph
        detection_graph = tf.Graph()
        with detection_graph.as_default():
                od_graph_def = tf.GraphDef()
                with tf.gfile.GFile(PATH_TO_CKPT, 'rb') as fid:
                        serialized_graph = fid.read()
                        od_graph_def.ParseFromString(serialized_graph)
                        tf.import_graph_def(od_graph_def, name='')
    #loading label map
        label_map = label_map_util.load_labelmap(PATH_TO_LABELS)
        categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=NUM_CLASSES, use_display_name=True)
        global category_index
        category_index = label_map_util.create_category_index(categories)
        #start detection

def get_recognize(img_path):
        with detection_graph.as_default():
                with tf.Session(graph=detection_graph) as sess:
                        nTimeNow = time.time()
                        image = Image.open(img_path)
                        rgb_im = image.convert('RGB')
                        # the array based representation of the image will be used later in order to prepare the
                      # result image with boxes and labels on it.
                        image_np = load_image_into_numpy_array(rgb_im)
                        # Expand dimensions since the model expects images to have shape: [1, None, None, 3]
                        image_np_expanded = np.expand_dims(image_np, axis=0)
                        image_tensor = detection_graph.get_tensor_by_name('image_tensor:0')
                        # Each box represents a part of the image where a particular object was detected.
                        boxes = detection_graph.get_tensor_by_name('detection_boxes:0')
                        # Each score represent how level of confidence for each of the objects.
                        # Score is shown on the result image, together with the class label.
                        scores = detection_graph.get_tensor_by_name('detection_scores:0')
                        classes = detection_graph.get_tensor_by_name('detection_classes:0')
                        num_detections = detection_graph.get_tensor_by_name('num_detections:0')
                        # Actual detection.
                        (boxes, scores, classes, num_detections) = sess.run([boxes, scores, classes, num_detections], feed_dict={image_tensor: image_np_expanded})
                        # vis_util.visualize_boxes_and_labels_on_image_array(image_np, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8)
                        nTimeFinal = time.time()
                        print("Time elapsed is "+str(nTimeFinal - nTimeNow)+ "s")

                        (w, h) = rgb_im.size
                        return output_boxes_array(w, h, 0, np.squeeze(boxes), np.squeeze(classes), np.squeeze(scores), category_index)
                        # os.remove(img_path)


import numpy as np
import cv2

def run_rcnn_on_rgbimg(image_np, w, h, ts):
        with detection_graph.as_default():
                with tf.Session(graph=detection_graph) as sess:
                        nTimeNow = time.time()
                        #image = Image.open(img_path)
                        #rgb_im = image.convert('RGB')
                        # the array based representation of the image will be used later in order to prepare the
                      # result image with boxes and labels on it.
                        #image_np = load_image_into_numpy_array(rgb_im)
                        # Expand dimensions since the model expects images to have shape: [1, None, None, 3]
                        image_np_expanded = np.expand_dims(image_np, axis=0)
                        image_tensor = detection_graph.get_tensor_by_name('image_tensor:0')
                        # Each box represents a part of the image where a particular object was detected.
                        boxes = detection_graph.get_tensor_by_name('detection_boxes:0')
                        # Each score represent how level of confidence for each of the objects.
                        # Score is shown on the result image, together with the class label.
                        scores = detection_graph.get_tensor_by_name('detection_scores:0')
                        classes = detection_graph.get_tensor_by_name('detection_classes:0')
                        num_detections = detection_graph.get_tensor_by_name('num_detections:0')
                        # Actual detection.
                        (boxes, scores, classes, num_detections) = sess.run([boxes, scores, classes, num_detections], feed_dict={image_tensor: image_np_expanded})
                        # vis_util.visualize_boxes_and_labels_on_image_array(image_np, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), category_index, use_normalized_coordinates=True, line_thickness=8)
                        nTimeFinal = time.time()
                        print("Time elapsed is "+str(nTimeFinal - nTimeNow)+ "s")

                        return output_boxes_array(w, h, ts, np.squeeze(boxes), np.squeeze(classes), np.squeeze(scores), category_index)


def run_rcnn_on_vid(vid_path, isVideo=True, frameID=0):
        cap = cv2.VideoCapture(vid_path)
        if(cap.isOpened() == False):
                print("video not opened " + vid_path)
                cap.open(vid_path)
        cap.set(cv2.CAP_PROP_CONVERT_RGB, True)
        w = cap.get(cv2.CAP_PROP_FRAME_WIDTH)
        h = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
        jsonbox_list = []
        while(True):
                ret, frame = cap.read()
                if(isVideo == False):
                        ts = frameID * 1000;
                        print("ts = " + str(ts))
                else:
                        ts = cap.get(cv2.CAP_PROP_POS_MSEC)
                if(ret == False):
                        print("could not read frame " + vid_path)
                        break
                #rgb_im = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                #cv2.imshow('frame', frame)
                #cv2.waitKey(33)
                jsonbox_list.extend(run_rcnn_on_rgbimg(frame, w, h, ts))
        cap.release()
        #cv2.destroyAllWindows()
        return jsonbox_list

# global i
# i = 0
#load_models(path = '/home/unnikrishnan/work/tensorflow/lib/python3.5/site-packages/tensorflow/models/object_detection/')
# while i <= 1017:
# global count
# count = 0
# focus()
# zoom_in()
# get_screenshot()
#get_recognize('test_images/evaluate.png')
#run_rcnn_on_vid("/home/unnikrishnan/work/tensorflow/lib/python3.5/site-packages/tensorflow/models/object_detection/test_images/1080p_WALSH_ST_000.mp4")
# zoom_out()
# choose_labels()
# focus()
# time.sleep(1)
# next_frame()
# time.sleep(2)
        # i+=1




